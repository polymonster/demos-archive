/****************************************
/	Al (c) 2008 - level.cpp
/****************************************
/	Draw 2D level
/****************************************/


/*************** INCLUDES ***************/

#include <stdio.h>
#include <iostream>
#include <fstream>

#include "d3dapp.h"
#include "d3dtex.h"
#include "dappinput.h"
#include "paths.h"

#include "level.h"
#include "soundManager.h"


/*************** CONSTANTS **************/



/*********** GLOBAL VARIABLES ***********/

LPDIRECT3DVERTEXBUFFER9		g_level_buffer	= NULL;

Level	*g_level_p;

char g_type_commands[][32] =
{
	"energy_cell",
	"intercom",
	"gate",
	"control_panel",
	"turret",
	"smartball"

};

/********* FUNCTION DEFINITIONS *********/

Level::Level() {}

Level::Level( char *tileset_p, char *map_filename_p, int origin_y, int size, int tiles, bool editor ) :
	m_current_map_x( 127 ),
	m_current_map_y( 127 ),
	m_tile_size( size ),
	m_edit_mode( editor ),
	m_editor_mode( EDIT_MODE_LEVEL_BUILDER ),
	m_num_nodes( 0 ),
	m_save( false ),
	m_edit_cursor( 1 ),
	m_edit_cursor_p( NULL ),
	m_hard_tileset_handle( -1 ),
	m_soft_tileset_handle( -1 ),
	m_num_tex_tiles( tiles ),
	m_origin_y( origin_y ),
	m_tilemap_p( m_tilemap ),
	m_mapdata_p( NULL ),
	m_gate_type( 0 ),
	m_col( 0xffffffff )
{

	set_priority( RENDER_MIDDLE );

	m_number_of_collectables = 0;
	m_number_of_turrets = 0;
	m_number_of_control_panels = 0;
	m_number_of_gates = 0;
	m_number_of_traps = 0;
	m_number_of_smartballs = 0;

	char fullpath[64];
	sprintf( fullpath, "%s%s.tga", PATH_TILESETS, tileset_p );
	m_tileset = load_d3d_texture( fullpath );

	sprintf( fullpath, "%s%s.tga", PATH_GUI, "editcurs" );
	m_edit_cursors = load_d3d_texture( fullpath );

	sprintf( m_map_filename, map_filename_p );

	memset( m_edit_node_p, 0, 4 * MAX_NODES );

	if( !m_edit_mode )
		init_objects();

	// load up the first level
	set_new_map( MAP_SCROLL_NONE );

	if( m_edit_mode )
	{

		sprintf( m_turret_options[TURRET_TYPE_CANNON], "Cannon" );
		sprintf( m_turret_options[TURRET_TYPE_ROCKET], "Rocket Launcher" );
		sprintf( m_turret_options[TURRET_TYPE_LAZER], "Lazer" );
		char *turrets_p = (char *)m_turret_options;

		sprintf( m_gate_options[GATE_BRIDGE], "Bridge" );
		sprintf( m_gate_options[GATE_DOOR], "Door" );
		char *cps_p = (char *)m_gate_options;

		int doit = 0;
		m_edit_buttons_p[EDIT_MODE_PLACE_ENERGY_CELL] = new GUINode( "Energy Cell", 55, 280, (int*)&m_editor_mode, 0 );
		m_edit_buttons_p[EDIT_MODE_PLACE_INTERCOM] = new GUINode( "Intercom", 55, 300, (int*)&m_editor_mode, 1 );
		m_edit_buttons_p[EDIT_MODE_PLACE_GATE] = new GUINode( "Gate", 55, 320, (int*)&m_editor_mode, 2, 2, cps_p );
		m_edit_buttons_p[EDIT_MODE_PLACE_CP] = new GUINode( "Control Panel", 55, 340, (int*)&m_editor_mode, 3 );
		m_edit_buttons_p[EDIT_MODE_PLACE_TURRET] = new GUINode( "Turret", 55, 360, (int*)&m_editor_mode, 4, 3, turrets_p );
		m_edit_buttons_p[EDIT_MODE_PLACE_ELECTROBALL] = new GUINode( "Smartball", 55, 380, (int*)&m_editor_mode, 5 );

		// create some tileset panels for selecting texture frames
		float wh = size * size;
		Quad *fghard_tileset_edit_p = new Quad( PATH_TILESETS, tileset_p, g_window_w - wh - size, origin_y+(MAP_HEIGHT*size)+(size*2), wh, wh/2.0f );
		Quad *fgsoft_tileset_edit_p = new Quad( PATH_TILESETS, tileset_p, g_window_w - (wh*2.0f), origin_y+(MAP_HEIGHT*size)+size, wh, wh/2.0f );

		fghard_tileset_edit_p->set_texcoords( 0.0f, 1.0f, 0.0f, 0.5f );
		fgsoft_tileset_edit_p->set_texcoords( 0.0f, 1.0f, 0.5f, 1.0f );

		m_hard_tileset_handle = fghard_tileset_edit_p->get_handle();
		m_soft_tileset_handle = fgsoft_tileset_edit_p->get_handle();

		// create tile mapping cursor at mouse position
		int mx, my;
		get_mouse_pos( mx, my );
		m_edit_cursor_p = new Quad( PATH_TILESETS, "", mx, my, 16, 16 );
		m_edit_cursor_p->set_priority( RENDER_NEAR_FRONT );
		m_edit_cursor_p->set_texture( m_tileset );

		// read correct UVs for m_edit_cursor index
		int tiles_per_row = (int)sqrtf( (float)m_num_tex_tiles );
		float uvsize = 1.0f / (float)tiles_per_row;
		float pos = ( (float)(m_edit_cursor-1) / (float)tiles_per_row );
		float v = (int)pos * uvsize;
		float u = pos - (int)pos;
		m_edit_cursor_p->set_texcoords( u, u + uvsize, v, v + uvsize );
	}

	g_d3d_device->SetVertexShader( NULL );

	int verts = ( ( MAP_WIDTH * 4 ) * MAP_HEIGHT ) + ( 4 * MAP_HEIGHT );
    // create a vertex buffer interface
    g_d3d_device->CreateVertexBuffer( verts * sizeof( level_vert_s ), 0, CUSTOM_STRIP_FVF, D3DPOOL_MANAGED, &g_level_buffer, NULL );

	set_slope_formulas();

	sprintf( fullpath, "%s%s.tga", PATH_SPRITES, "bullet" );
	m_projectile_tex[0] = load_d3d_texture( fullpath );
	sprintf( fullpath, "%s%s.tga", PATH_SPRITES, "missile" );
	m_projectile_tex[1] = load_d3d_texture( fullpath );
	sprintf( fullpath, "%s%s.tga", PATH_SPRITES, "lazer" );
	m_projectile_tex[2] = load_d3d_texture( fullpath );

}

void Level::init_objects()
{
	vector2 pos;
	pos.x = 0;
	pos.y = 0;

	vector2 sizew;
	sizew.x = 0;
	sizew.y = 0;

	for(int i = 0; i < MAX_PROJECTILES; i++)
	{
		m_projectile[i] = new Projectile(pos,sizew,1,"missile");
	}

	for(int i = 0; i < MAX_PARTICLES; i++)
	{
		m_particle[i] = new Particle(pos,"smoke");
	}

	m_spawn_pos.x = 60;
	m_spawn_pos.y = 140;

	FSOUND_STREAM *m = NULL;
	g_sound_mgr_p->loadAndPlay("sound/music/musics.mp3",g_music_volume,&m);

#if 0


	//This is a messy function to be replace by the editor (Y)

	if( !m_edit_mode )
	{
		m_number_of_turrets = 6;
		m_number_of_gates = 2;
		m_number_of_control_panels = 2;

		vector2 pos;
		vector2 sizew;

		pos.x = 355;
		pos.y = 148;

		sizew.x = 100;
		sizew.y = 10;

		m_blockers = new Blocker*[m_number_of_gates];
		m_blockers[0] = new Blocker(pos,sizew,1,BRIDGE,"door");

		pos.x = 260;
		pos.y = 160;

		sizew.x = 10;
		sizew.y = 120;

		m_blockers[1] = new Blocker(pos,sizew,1,DOOR,"door");

		pos.x = 375;
		pos.y = 290;

		m_control_panels = new ControlPanel*[m_number_of_control_panels];
		m_control_panels[0] = new ControlPanel(pos,1,"door");
		m_control_panels[0]->assign_sound("sound/hellyeah.mp3");

		pos.x = 420;
		pos.y = 220;
		m_control_panels[1] = new ControlPanel(pos,0,"door");

		m_turrets = new Turret*[m_number_of_turrets];

		pos.x = 16;
		pos.y = 240;
		m_turrets[0] = new Turret(pos,2,1,2,60,"turret");

		pos.y -= 40;
		m_turrets[1] = new Turret(pos,2,1,2,60,"turret");

		pos.y -= 40;
		m_turrets[2] = new Turret(pos,2,1,2,60,"turret");

		pos.x += 80;
		pos.y = 16 + m_origin_y;
		m_turrets[3] = new Turret(pos,2,2,2,60,"turret");

		pos.x += 40;
		m_turrets[4] = new Turret(pos,2,2,0,60,"turret");
		
		pos.x = 530;
		pos.y = 16 + m_origin_y;
		m_turrets[5] = new Turret(pos,2,2,0,50,"turret");

		m_number_of_collectables = 10;

		m_collectables = new Collectable*[m_number_of_collectables];

		pos.x = 35;
		pos.y = 203;
		m_collectables[0] = new Collectable(pos,1,"collectable");

		pos.x = 59;
		pos.y = 156;
		m_collectables[1] = new Collectable(pos,1,"collectable");

		pos.x = 97;
		pos.y = 179;
		m_collectables[2] = new Collectable(pos,1,"collectable");

		pos.x = 140;
		pos.y = 162;
		m_collectables[3] = new Collectable(pos,1,"collectable");

		pos.x = 161;
		pos.y = 138;
		m_collectables[4] = new Collectable(pos,1,"collectable");

		pos.x = 235;
		pos.y = 138;
		m_collectables[5] = new Collectable(pos,2,"collectable");

		pos.x = 277;
		pos.y = 140;
		m_collectables[6] = new Collectable(pos,2,"collectable");

		pos.x = 350;
		pos.y = 125;
		m_collectables[7] = new Collectable(pos,2,"collectable");

		pos.x = 582;
		pos.y = 183;
		m_collectables[8] = new Collectable(pos,2,"collectable");

		pos.x = 563;
		pos.y = 346;
		m_collectables[9] = new Collectable(pos,2,"collectable");

		m_number_of_traps = 2;

		m_traps = new Trap *[m_number_of_traps];
		pos.y = 100;

		vector2 range;
		range.x = 1;
		range.y = 5;

		vector2 speed;
		speed.x = 5;
		speed.y = 3;

		m_traps[0] = new Trap(pos,1,range,speed,"trap");

		pos.x = 108;
		pos.y = 334;

		range.x = 1;
		range.y = 5;

		speed.x = 5;
		speed.y = 3;

		m_traps[1] = new Trap(pos,-1,range,speed,"trap");

		FSOUND_STREAM *m = NULL;
		g_sound_mgr_p->loadAndPlay("sound/musics.mp3",20,&m);

		acid_anim_timer = 1;
	}
#endif
}


Level::~Level()
{
	if( m_mapdata_p )
		delete [] m_mapdata_p;

	for( int i = 0; i < 3; i++ )
		if( m_projectile_tex[i].texture )
			m_projectile_tex[i].texture->Release();

	m_tileset.texture->Release();

	if( g_level_buffer )
		g_level_buffer->Release();
}

void Level::spawn_particle(vector2 position)
{
	for(int i = 0; i < MAX_PARTICLES; i++)
	{
		if(!m_particle[i]->active())
		{
			m_particle[i]->spawn(position);
			i = MAX_PARTICLES;
		}
	}
}

void Level::spawn_particle(vector2 position, int type)
{
	for(int i = 0; i < MAX_PARTICLES; i++)
	{
		if(!m_particle[i]->active())
		{
			m_particle[i]->spawn(position,type);
			i = MAX_PARTICLES;
		}
	}
}


void Level::execute( void )
{
	//HERE WE NEED TO CHECK IF WE NEED TO SPAWN A NEW PROJECTILES

	if( !m_edit_mode )
	{
		vector2 pos;
		vector2 dir;

		for(int i = 0; i < m_number_of_turrets; i++)
		{
			int res = m_turrets[i]->shoot(&pos, &dir);

			if(res != -1)
			{
				for(int j = 0; j < MAX_PROJECTILES; j++)
				{
					if(!m_projectile[j]->active()) 
					{
						m_projectile[j]->spawn(pos,dir,res);
						j = MAX_PROJECTILES;
					}
				}
			}
		}

		//HERE WE CHECK TO SPAWN PARTICLES FOR THE MISSILE "TAILS"
		for(int i = 0; i < MAX_PROJECTILES; i++)
		{
			if(m_projectile[i]->active()) 
			{
				if(m_projectile[i]->emmit_particle())
				{
					for(int j = 0; j < MAX_PARTICLES; j++)
					{
						if(!m_particle[j]->active())
						{
							m_particle[j]->spawn(m_projectile[i]->particle_pos());
							j = MAX_PARTICLES;
						}
					}
				}
			}
		}

		acid_anim_timer -= g_scene_p->m_game_time;

		if(acid_anim_timer <= 0)
		{
			animate_acid();
			acid_anim_timer = 0.1f;
		}

	}
	else
	{

		int mx, my;
		get_mouse_pos( mx, my );

		if( m_editor_mode != EDIT_MODE_LEVEL_BUILDER && m_edit_cursor_p->get_texture().texture != m_edit_cursors.texture )
			m_edit_cursor_p->set_texture( m_edit_cursors );

		if( mouse_button_click( 0 ) )
		{
			Quad *hard_set_p = (Quad *)g_object_list_p->get_obj( m_hard_tileset_handle );
			Quad *soft_set_p = (Quad *)g_object_list_p->get_obj( m_soft_tileset_handle );

			vector2 h_pos = hard_set_p->get_pos();
			vector2 h_size = hard_set_p->get_size();
			if( mx > h_pos.x && my > h_pos.y && mx < h_pos.x + h_size.x && my < h_pos.y + h_size.y )
			{
				int idx = ( mx - h_pos.x ) / m_tile_size;
				int idy = ( my - h_pos.y ) / m_tile_size;
				m_edit_cursor = idx + ( idy * m_tile_size ) + 1;
				m_editor_mode = EDIT_MODE_LEVEL_BUILDER;
				m_edit_cursor_p->set_texture( m_tileset );
			}
			else
			{
				vector2 h_pos = soft_set_p->get_pos();
				vector2 h_size = soft_set_p->get_size();
				if( mx > h_pos.x && my > h_pos.y && mx < h_pos.x + h_size.x && my < h_pos.y + h_size.y )
				{
					int idx = ( mx - h_pos.x ) / m_tile_size;
					int idy = ( my - h_pos.y ) / m_tile_size;
					m_edit_cursor = idx + ( idy * m_tile_size ) + 129;
					m_editor_mode = EDIT_MODE_LEVEL_BUILDER;
					m_edit_cursor_p->set_texture( m_tileset );
				}
			}

			// read correct UVs for m_edit_cursor index
			int tiles_per_row = (int)sqrtf( (float)m_num_tex_tiles );
			float uvsize = 1.0f / (float)tiles_per_row;
			float pos = ( (float)(m_edit_cursor-1) / (float)tiles_per_row );
			float v = (int)pos * uvsize;
			float u = pos - (int)pos;
			m_edit_cursor_p->set_texcoords( u, u + uvsize, v, v + uvsize );

		}

		// check top and bottom planes to show tile
		if( my > MAP_HEIGHT * m_tile_size - 5 )
			m_edit_cursor_p->m_hide = true;
		else
			m_edit_cursor_p->m_hide = false;

		// place stuff!
		if( m_edit_cursor_p && !m_edit_cursor_p->m_hide )
		{
			int x,y, index;
			bool bail = false;
			if( m_editor_mode != EDIT_MODE_LEVEL_BUILDER )
			{
				// set to current tile under mouse
				vector2 loc;
				loc.x = (int)mx / m_tile_size;
				loc.y = (int)my / m_tile_size;
				x = loc.x;
				y = loc.y;
				index = (y*MAP_WIDTH)+x;

				for( int i = 0; i < MAX_NODES; i++ )
				{
					if( m_edit_node_p[i] && m_edit_node_p[i]->m_data.pos == loc )
					{
						bail = true;
						if( mouse_button_down( 1 ) )
						{
							switch( m_edit_node_p[i]->m_type )
							{
							case NODE_CP:
								m_number_of_control_panels--;
								break;
							case NODE_INTERCOM:
								m_number_of_intercoms--;
							}

							int handle = m_edit_node_p[i]->get_handle();
							g_object_list_p->remove( handle );
							m_edit_node_p[i] = NULL;
							break;
						}
					}
				}

			}

			switch( m_editor_mode )
			{
				case EDIT_MODE_PLACE_TURRET:
				{
					float rot = m_edit_cursor_p->get_rotation();
					if(  mouse_button_click( 2 ) )
						m_edit_cursor_p->set_rotation( rot >= 250.0f ? 0.0f : rot + 90.0f );

					m_edit_cursor_p->rotate( m_edit_cursor_p->get_rotation() );

					if( !bail && !m_tilemap[index] )
					{
						m_edit_cursor_p->set_col( 0xffffffff );
						if( mouse_button_click( 0 ) )
						{
							node_data_s data;
							data.pos.x = x;
							data.pos.y = y;
							data.turret_direction = (int)(m_edit_cursor_p->get_rotation() / 90);
							data.turret_type = m_edit_buttons_p[EDIT_MODE_PLACE_TURRET]->m_selection;
							int free = 0;
							while( m_edit_node_p[free] ) free++;
							m_edit_node_p[free] = new EditNode( NODE_TURRET, data );
						}
					}
					else
						m_edit_cursor_p->set_col( 0x40ff1010 );

					m_edit_cursor_p->set_pos( (x * m_tile_size) + ( m_edit_cursor_p->get_size().x * 0.5 ), (y * m_tile_size) + ( m_edit_cursor_p->get_size().y * 0.5 ) );
					m_edit_cursor_p->set_texcoords( 0.25f, 0.5f, 0.0f, 0.25f );
					m_edit_cursor_p->set_size( 16.0f, 16.0f );

				}
				break;

				case EDIT_MODE_PLACE_ENERGY_CELL:
				{
					if( !bail && !m_tilemap[index] )
					{
						m_edit_cursor_p->set_col( 0xffffffff );
						if( mouse_button_click( 0 ) )
						{
							node_data_s data;
							data.pos.x = x;
							data.pos.y = y;
							int free = 0;
							while( m_edit_node_p[free] ) free++;
							m_edit_node_p[free] = new EditNode( NODE_ENERGY_CELL, data );
						}
					}
					else
						m_edit_cursor_p->set_col( 0x40ff1010 );

					m_edit_cursor_p->set_pos( x * m_tile_size + 4, y * m_tile_size + 4 );
					m_edit_cursor_p->set_texcoords( 0.0f, 0.25f, 0.0f, 0.25f );
					m_edit_cursor_p->set_size( 8.0f, 8.0f );

				}
				break;

				case EDIT_MODE_PLACE_CP:
				{
					if( m_number_of_control_panels >= MAX_CPS )
						bail = true;

					if( !bail && !m_tilemap[index] )
					{
						m_edit_cursor_p->set_col( 0xffffffff );
						if( mouse_button_click( 0 ) )
						{
							node_data_s data;
							data.pos.x = x;
							data.pos.y = y;
							int free = 0;
							while( m_edit_node_p[free] ) free++;
							data.gate_cp_handle = m_number_of_control_panels++;
							m_edit_node_p[free] = new EditNode( NODE_CP, data );
						}
					}
					else
						m_edit_cursor_p->set_col( 0x40ff1010 );

					m_edit_cursor_p->set_pos( x * m_tile_size + 4, y * m_tile_size + 4 );
					m_edit_cursor_p->set_texcoords( 0.5f, 0.75f, 0.0f, 0.25f );
					m_edit_cursor_p->set_size( 8.0f, 8.0f );

				}
				break;

				case EDIT_MODE_PLACE_GATE:
				{
					if(  mouse_button_click( 2 ) )
						m_gate_type = !m_gate_type;

					if( mouse_button_click( 0 ) )
					{
						for( int i = 0; i < MAX_NODES; i++ )
						{
							if( !m_edit_node_p[i] )
								break;
							else
							if( m_edit_node_p[i]->m_data.pos.x == x && m_edit_node_p[i]->m_data.pos.y == y )
							{
								if( m_edit_node_p[i]->m_data.gate_cp_handle < m_number_of_control_panels-1 )
									m_edit_node_p[i]->m_data.gate_cp_handle++;
								else
									m_edit_node_p[i]->m_data.gate_cp_handle = 0;
								break;
							}
						}
					}

					bail = false;

					if( m_number_of_gates >= MAX_GATES )
						bail = true;

					if( !bail && !m_tilemap[index] )
					{
						m_edit_cursor_p->set_col( 0xffffffff );
						if( mouse_button_click( 0 ) )
						{
							node_data_s data;
							data.pos.x = x;
							data.pos.y = y;
							int free = 0;
							while( m_edit_node_p[free] ) free++;
							data.gate_cp_handle = 0;
							data.gate_type = (int)m_gate_type;
							m_edit_node_p[free] = new EditNode( NODE_GATE, data );
						}
					}
					else
						m_edit_cursor_p->set_col( 0x40ff1010 );

					vector2 new_size;
					new_size.x = m_gate_type ? 64 : 10;
					new_size.y = !m_gate_type ? 64 : 10;
					m_edit_cursor_p->set_texcoords( 0.5f, 0.75f, 0.25f, 0.5f );
					m_edit_cursor_p->set_size( new_size.x, new_size.y );
					m_edit_cursor_p->set_pos( x * m_tile_size + 4, y * m_tile_size + 4 );

				}
				break;

				case EDIT_MODE_PLACE_INTERCOM:
				{
					if( m_number_of_intercoms >= MAX_INTERCOMS )
						bail = true;

					if( !bail && !m_tilemap[index] )
					{
						m_edit_cursor_p->set_col( 0xffffffff );
						if( mouse_button_click( 0 ) )
						{
							node_data_s data;
							data.pos.x = x;
							data.pos.y = y;
							int free = 0;
							while( m_edit_node_p[free] ) free++;
							data.intercom_id = m_number_of_intercoms++;
							m_edit_node_p[free] = new EditNode( NODE_INTERCOM, data );
						}
					}
					else
						m_edit_cursor_p->set_col( 0x40ff1010 );

					m_edit_cursor_p->set_pos( x * m_tile_size + 4, y * m_tile_size + 4 );
					m_edit_cursor_p->set_texcoords( 0.25f, 0.5f, 0.25f, 0.5f );
					m_edit_cursor_p->set_size( 8.0f, 8.0f );

				}
				break;

				case EDIT_MODE_PLACE_ELECTROBALL:
				{
					if( !bail && !m_tilemap[index] )
					{
						m_edit_cursor_p->set_col( 0xffffffff );
						if( mouse_button_click( 0 ) )
						{
							node_data_s data;
							data.pos.x = x;
							data.pos.y = y;
							int free = 0;
							while( m_edit_node_p[free] ) free++;
							m_edit_node_p[free] = new EditNode( NODE_ELECTROBALL, data );
						}
					}
					else
						m_edit_cursor_p->set_col( 0x40ff1010 );

					m_edit_cursor_p->set_pos( x * m_tile_size + 4, y * m_tile_size + 4 );
					m_edit_cursor_p->set_texcoords( 0.0f, 0.25f, 0.25f, 0.5f );
					m_edit_cursor_p->set_size( 8.0f, 8.0f );

				}
				break;

				case EDIT_MODE_LEVEL_BUILDER:
				{
					m_edit_cursor_p->set_col( 0xffffffff );
					// set to current tile under mouse
					int x = mx / m_tile_size;
					int y = my / m_tile_size;
					m_edit_cursor_p->set_pos( x * m_tile_size, y * m_tile_size );
					m_edit_cursor_p->set_size( 16.0f, 16.0f );

					int index = x + ( y * MAP_WIDTH );
					if( mouse_button_down( 0 ) )
					{
						m_tilemap_p[index] = m_edit_cursor;
					}
					else
					if( mouse_button_down( 1 ) )
					{
						m_tilemap_p[index] = 0;
					}
				}
				break;

			}
		}

		if( key_hit( DIK_M ) )
		{
			save_map();
			set_new_map( MAP_SCROLL_RIGHT );
			if( m_current_map_x > 126+m_map_rooms )
				m_map_rooms++;
		}
		else
		if( key_hit( DIK_N ) )
		{
			if( m_current_map_x > 127 )
			{
				save_map();
				set_new_map( MAP_SCROLL_LEFT );
			}

		}
	}

}


void Level::save_map( void )
{
//	if( m_save )
	{
		m_save = false;

		char data_filename[64];
		sprintf( data_filename, "data\\levels\\map1.hmp" );
		FILE *mapdata_p = fopen( data_filename, "rb" );

		int filelen = 0;
		while( !feof( mapdata_p ) )
		{
			fgetc( mapdata_p );
			filelen++;
		}
		rewind( mapdata_p );

		char *buf_p = new char[filelen];
		fread( buf_p, 1, filelen, mapdata_p );

		freopen( data_filename, "w", mapdata_p );

		char *eoh_p = strrchr( buf_p, 255 );
		int header_size = eoh_p - buf_p + 1;

		char header[128];
		strncpy( header, buf_p, header_size );
		header[header_size] = 0;

		char *full_buffer_p = buf_p;
		buf_p += strlen( header );

		int previous_num_rooms = 0;
		char *navh_p = header;
		while( char *p = strchr( navh_p, 255 ) )
		{
			navh_p = p+1;
			previous_num_rooms++;
		}
		previous_num_rooms /= 2;

		if( m_map_rooms > previous_num_rooms )
		{
			sprintf( header, "%c%d:%d%c", 255, 127, 127, 255 );
			char more[16];
			for( int i = 1; i < m_map_rooms; i++ )
			{
				sprintf( more, "%c%d:%d%c", 255, 127+i, 127, 255 );
				strcat( header, more );
			}
		}
		fwrite( (void *)header, strlen( header ), 1, mapdata_p );

		for( int i = 0; i < m_map_rooms; i++ )
		{
			if( m_current_map_x == 127+i )
			{
				fwrite( (void *)m_tilemap, 640, 1, mapdata_p );
				buf_p+=640;
				continue;
			}
			fwrite( (void *)buf_p, 640, 1, mapdata_p );
			buf_p+=640;
		}

		fclose( mapdata_p );

		delete [] full_buffer_p;
		dbgmsg( "Map file saved\n" );


		// -----------------------------------------------------------------

		std::ofstream fout;

		char path[64];
		sprintf( path, "%s%s_%d-%d.hmc", PATH_LEVELS, m_map_filename, m_current_map_x, m_current_map_y );
		fout.open( path );

		for( int i = 0; i < MAX_NODES; i++ )
		{
			if( !m_edit_node_p[i] )
				continue;

			node_type_e type = m_edit_node_p[i]->m_type;
			node_data_s *data_p = &m_edit_node_p[i]->m_data;

			fout << g_type_commands[type] << " ";
			fout << data_p->pos.x << " " << data_p->pos.y << " ";

			switch( type )
			{
			case NODE_ENERGY_CELL:
				break;
			case NODE_INTERCOM:
				fout << data_p->intercom_id << " ";
				break;
			case NODE_GATE:
				fout << data_p->gate_type << " " << data_p->gate_cp_handle << " ";
				break;
			case NODE_CP:
				fout << data_p->gate_cp_handle << " ";
				break;
			case NODE_TURRET:
				fout << data_p->turret_direction << " " << data_p->turret_type << " ";
				break;
			case NODE_ELECTROBALL:
				break;
			}

			fout << ";" << "\n";

			int handle = m_edit_node_p[i]->get_handle();
			g_object_list_p->remove( handle );
			m_edit_node_p[i] = NULL;

		}
		

		dbgmsg( "Map data saved\n" );
	}
}


void Level::render( void )
{
	int num_prims = 0;

	level_vert_s *vert_p = NULL;
	level_vert_s *vertzero_p = vert_p;

	int tiles_per_row = (int)sqrtf( (float)m_num_tex_tiles );
	float uvsize = 1.0f / (float)tiles_per_row;

	int num_tiles = MAP_WIDTH * MAP_HEIGHT;
	int x, y;
	x = y = 0;
	float v0, v1, u0, u1;

	int i = 0;
	while( !m_tilemap_p[i] )
		i++;

	// set first position
	set_vert_pos( x, y, i-1 );

	m_col = 0xffffffff;

    // lock buffer and load the vertices into it
	g_level_buffer->Lock( 0, 0, (void**)&vert_p, 0 );

	while( i < num_tiles )
	{

		int x_grid = (int)( (x+m_tile_size) / m_tile_size );
		if( ( x_grid != MAP_WIDTH ) && m_tilemap_p[i] )
		{
			x += m_tile_size;

			// first set of verts for quad

			// set new UVs
			v0 = ( ( m_tilemap_p[i]-1 ) / tiles_per_row ) * uvsize;
			v1 = v0 + uvsize;
			float upos = ( (float)( m_tilemap_p[i]-1 ) / (float)tiles_per_row );
			u0 = ( upos - (int)upos );
			u1 = u0 + uvsize;

			set_vert( vert_p, x, y, u0, v0, 0 );
			vert_p++;
			set_vert( vert_p, x, y + m_tile_size, u0, v1, 0 );
			vert_p++;

			num_prims += 2;
		}
		else
		{
			// degens

			// previous vert copy
			set_vert( vert_p, x + m_tile_size, y + m_tile_size, u1, v1, 0 );
			vert_p++;

			// find the next vert, increment iterator
			while( !m_tilemap_p[i] && i < num_tiles )
				i++;

			set_vert_pos( x, y, i );

			// new vert copy
			set_vert( vert_p, x, y, u0, v1, 0 );
			vert_p++;

			// set new UVs
			v0 = ( ( m_tilemap_p[i]-1 ) / tiles_per_row ) * uvsize;
			v1 = v0 + uvsize;
			float upos = ( (float)( m_tilemap_p[i]-1 ) / (float)tiles_per_row );
			u0 = ( upos - (int)upos );
			u1 = u0 + uvsize;

			set_vert( vert_p, x, y, u0, v0, 0 );
			vert_p++;
			set_vert( vert_p, x, y + m_tile_size, u0, v1, 0 );
			vert_p++;

			num_prims += 4;

		}

		// second pair in quad
		set_vert( vert_p, x + m_tile_size, y, u1, v0, 0 );
		vert_p++;
		set_vert( vert_p, x + m_tile_size, y + m_tile_size, u1, v1, 0 );
		vert_p++;

		i++;

		num_prims += 2;

	}

	g_level_buffer->Unlock();


	g_d3d_device->SetTexture( 0, m_tileset.texture );

	g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP );
	g_d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP );

	g_d3d_device->SetRenderState( D3DRS_LIGHTING, FALSE );
	g_d3d_device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	g_d3d_device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	g_d3d_device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	g_d3d_device->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_MODULATE );

	g_d3d_device->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );

	g_d3d_device->SetStreamSource( 0, g_level_buffer, 0, sizeof( level_vert_s ) );
	g_d3d_device->SetFVF( CUSTOM_STRIP_FVF );

	// copy the vertex buffer to the back buffer
	g_d3d_device->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, num_prims );

	//*********************************************************************//

	if( m_edit_mode )
	{
		char mode[32];
		if( m_editor_mode != EDIT_MODE_LEVEL_BUILDER )
			sprintf( mode, "[red]INTERIOR MODE" );
		else
			sprintf( mode, "[red]MAP EDITOR MODE" );
		g_mini_font_p->print_2d_text( mode, 420, 450 );

		g_mini_font_p->print_2d_text( "Tileset", 368.0f, 270.0f );


	}

	//render these objects **they render with out this but wasnt sure on how
	//to order them correctly (they were drawing behind)

	// LIST NOW SORTED. Left these in for reference, if they need render priority sorted.
	// usage: Stick a "set_priority( float priority );" in the object's constructor, or anywhere you need.
	// There are defines for the parameter, such as RENDER_NEAR_FRONT. -AB

	//if( !m_edit_mode )
	//{
	//	for(int i = 0; i < MAX_PARTICLES; i++)
	//	{
	//		m_particle[i]->render();
	//	}

	//	for(int i = 0; i < MAX_PROJECTILES; i++)
	//	{
	//		m_projectile[i]->render();
	//	}

	//	for(int i = 0; i < m_number_of_turrets; i++)
	//	{
	//		m_turrets[i]->render();
	//	}

	//	for(int i = 0; i < m_number_of_collectables; i++)
	//	{
	//		m_collectables[i]->render();
	//	}

	//	for(int i = 0; i < m_number_of_traps; i++)
	//	{
	//		m_traps[i]->render();
	//	}
	//}
}


void Level::set_vert( level_vert_s *fvf_struct_p, int x, int y, float u, float v, int iterator )
{
	fvf_struct_p[iterator].x	= (float)x;
	fvf_struct_p[iterator].y	= (float)y;
	fvf_struct_p[iterator].z	= 0.0f;
	fvf_struct_p[iterator].rhw	= 1.0f;
	fvf_struct_p[iterator].col	= m_col;
	fvf_struct_p[iterator].u	= u;
	fvf_struct_p[iterator].v	= v;
}

void Level::set_vert_pos( int &x, int &y, int tile )
{
	int idx = tile;
	int idy = 0;
	while( idx >= MAP_WIDTH )
	{
		idx -= MAP_WIDTH;
		idy++;
	}
	x = m_tile_size * idx;
	y = m_origin_y + ( m_tile_size * idy );
}


void Level::set_new_map( int scroll_dir )
{

	if( !m_edit_mode )
	{
		for(int i = 0; i < MAX_PROJECTILES; i++)
			m_projectile[i]->kill();
		for(int i = 0; i < MAX_PARTICLES; i++)
			m_particle[i]->m_hide = true;
	}

	int new_map_y = m_current_map_y;
	int new_map_x = m_current_map_x;

	// set new map location
	if( scroll_dir != -1 )
	{
		scroll_dir > MAP_SCROLL_RIGHT ?
			( scroll_dir == MAP_SCROLL_UP ? new_map_y-- : new_map_y++ ) :
			( scroll_dir == MAP_SCROLL_LEFT ? new_map_x-- : new_map_x++ );
	}

	char map_buf[32];
	char mapx[8];
	char mapy[8];
	int info_id = 0;
	int len = 0;
	bool found = false;

	// load map file
	char data_filename[64];
	sprintf( data_filename, "data\\levels\\%s.hmp", m_map_filename );
	FILE *mapfile_p = fopen( data_filename, "rb" );

	int filelen = 0;
	while( !feof( mapfile_p ) )
	{
		fgetc( mapfile_p );
		filelen++;
	}

	rewind( mapfile_p );

	m_mapdata_p = new byte[(filelen+8)];
	fread( m_mapdata_p, 1, sizeof( byte ) * filelen, mapfile_p );

	fclose( mapfile_p );

	int num_rooms = 0;
	char *navh_p = (char *)m_mapdata_p;
	while( char *p = strchr( navh_p, 255 ) )
	{
		navh_p = p+1;
		num_rooms++;
	}
	num_rooms /= 2;
	m_map_rooms = num_rooms;

	// point to map data
	byte *mapread_p = m_mapdata_p;

	// point to end of the last header in the map file
	char *eoh_p = strrchr( (char *)m_mapdata_p, 255 );

	while( (char *)mapread_p != (eoh_p+1) )
	{
		len = 1;
		// get the length of this map info
		while( *(mapread_p+len) != 255 )
			len++;

		// get the current map info
		strncpy( map_buf, (char *)mapread_p, len+1 );
		map_buf[len+1] = 0;
		char *map_p = map_buf+1;
		
		// get coordinates
		int len2 = 0;
		while( map_p[len2] != ':' )
		{
			mapx[len2] = map_p[len2];
			len2++;
		}
		mapx[len2] = 0;
		map_p += len2+1;
		len2 = 0;
		while( map_p[len2] != -1 )
		{
			mapy[len2] = map_p[len2];
			len2++;
		}
		mapy[len2] = 0;

		// coords match the map we are looking for
		if( atoi( mapx ) == new_map_x && atoi( mapy ) == new_map_y )
		{
			found = true;
			m_current_map_y = new_map_y;
			m_current_map_x = new_map_x;
			// read in map data
			char *mapinfo_p = (eoh_p+(info_id*640)+1);
			memcpy( (char *)&m_tilemap, mapinfo_p, 640 );

			// ----- LOAD MAP ELEMENTS -----

			if( !m_edit_mode )
			{
				for( int i = 0; i < m_number_of_collectables; i++ )
				{
					int handle = m_collectables[i]->get_handle();
					g_object_list_p->remove( handle );
					m_collectables[i] = NULL;
				}

				for( int i = 0; i < m_number_of_turrets; i++ )
				{
					int handle = m_turrets[i]->get_handle();
					g_object_list_p->remove( handle );
					m_turrets[i] = NULL;
				}

				for( int i = 0; i < m_number_of_smartballs; i++ )
				{
					int handle = m_smartballs[i]->get_handle();
					g_object_list_p->remove( handle );
					m_smartballs[i] = NULL;
				}

				for( int i = 0; i < m_number_of_control_panels+m_number_of_intercoms; i++ )
				{
					int handle = m_control_panels[i]->get_handle();
					g_object_list_p->remove( handle );
					m_control_panels[i] = NULL;
				}

				for( int i = 0; i < m_number_of_gates; i++ )
				{
					int handle = m_blockers[i]->get_handle();
					g_object_list_p->remove( handle );
					m_blockers[i] = NULL;
				}
			}

			m_number_of_gates =
			m_number_of_collectables =
			m_number_of_turrets =
			m_number_of_smartballs =
			m_number_of_control_panels =
			m_number_of_intercoms = 0;

			std::ifstream fin;

			char path[64];
			sprintf( path, "%s%s_%d-%d.hmc", PATH_LEVELS, m_map_filename, new_map_x, new_map_y );
			fin.open( path );

			char command[32];
			for( int i = 0; i < MAX_NODES; i++ )
			{

				fin >> command;

				if( !command[0] )
					break;

				node_data_s data;
				node_type_e type;
				for( int i = 0; i < 6; i++ )
				{
					if( !strcmp( command, g_type_commands[i] ) )
					{
						type = (node_type_e)i;
						break;
					}
				}

				fin >> data.pos.x >> data.pos.y;

				if( !m_edit_mode )
				{
					vector2 pos = data.pos;
					pos.x = ( data.pos.x * m_tile_size ) + ( m_tile_size - g_nodedims[type].x );
					pos.y = ( data.pos.y * m_tile_size ) + ( m_tile_size - g_nodedims[type].y );
					pos.y += m_origin_y;

					switch( type )
					{
					case NODE_ENERGY_CELL:
						m_collectables[m_number_of_collectables++] = new Collectable( pos, 1, "collectable" );
						break;
					case NODE_INTERCOM:
						{
							fin >> data.intercom_id;
							int id = m_number_of_intercoms+m_number_of_control_panels;
							m_control_panels[id] = new ControlPanel( pos, data.intercom_id, "intercom" );
							char soundfile[32];
							sprintf( soundfile, "sound/dialog/com_%d_%d.mp3", m_current_map_x - 127, data.intercom_id );
							m_control_panels[id]->assign_sound( soundfile );
							m_number_of_intercoms++;
						}
						break;
					case NODE_GATE:
						fin >> data.gate_type;
						fin >> data.gate_cp_handle;
						vector2 dims;
						if( data.gate_type )
						{
							dims.x = 64;
							dims.y = 10;
						}
						else
						{
							dims.x = 10;
							dims.y = 64;
						}

						pos.x = ( data.pos.x * m_tile_size );
						pos.y = ( data.pos.y * m_tile_size );
						pos.y += m_origin_y;

						m_blockers[m_number_of_gates++] = new Blocker( pos, dims, 1, data.gate_type, data.gate_cp_handle, data.gate_type == DOOR ? "door" : "bridge" );
						break;
					case NODE_CP:
						fin >> data.gate_cp_handle;
						m_control_panels[m_number_of_control_panels+m_number_of_intercoms] = new ControlPanel( pos, data.gate_cp_handle, "cp0" );
						m_number_of_control_panels++;
						break;
					case NODE_TURRET:
						fin >> data.turret_direction >> data.turret_type;
						m_turrets[m_number_of_turrets++] = new Turret( pos, 2, data.turret_direction, data.turret_type, 60, "turret" );
						break;
					case NODE_ELECTROBALL:
						m_smartballs[m_number_of_smartballs++] = new Actor( "fizzball", pos.x, pos.y );
						break;
					}
				}
				else
				{

					switch( type )
					{
					case NODE_ENERGY_CELL:
						break;
					case NODE_INTERCOM:
						fin >> data.intercom_id;
						m_number_of_intercoms++;
						break;
					case NODE_GATE:
						fin >> data.gate_type;
						fin >> data.gate_cp_handle;
						break;
					case NODE_CP:
						fin >> data.gate_cp_handle;
						m_number_of_control_panels++;
						break;
					case NODE_TURRET:
						fin >> data.turret_direction >> data.turret_type;
						break;
					case NODE_ELECTROBALL:
						break;
					}

					m_edit_node_p[i] = new EditNode( type, data );

					
				}

				fin >> command;
					
			}

			// -----------------------------

		}

		// keep looking for a match?
		if( !found )
		{
			mapread_p += len+1;
			info_id++;
		}
		else
			break;

	}

	if( !found )
	{
		memset( m_tilemap, 1, 640 );
	}

	delete [] m_mapdata_p;
	m_mapdata_p = NULL;

	m_current_map_x = new_map_x;
	m_current_map_y = new_map_y;

}

int Level::get_grid_x( int pos )
{
	return( (int)( pos / m_tile_size ) );
}

int Level::get_grid_y( int pos )
{
	return( (int)( ( pos - (float)m_origin_y ) / m_tile_size ) );
}

int Level::hit_collidable_tile	( int tile	)
{ 
	if(tile == 0) return 0;
	else if(tile < 17) return 1;
	else if(tile > 16 && tile < 36) return 2;
	else if(tile >= 36 && tile <= 42) return 3;
	else if(tile >= 43 && tile <= 47) return 4;
	else return 0;
}

void Level::obtainGates(vector2 *position, vector2 *dimensions,int id)
{
	*position = m_blockers[id]->get_pos();
	*dimensions = m_blockers[id]->get_size();
}

void Level::animate_acid()
{
	for(int i = 0; i < MAP_SIZE; i++)
	{
		if(m_tilemap[i] >= 43 && m_tilemap[i] <= 47)
		{
			m_tilemap[i]++;
			if(m_tilemap[i] > 47) m_tilemap[i] = 43;
		}
	}
}

void Level::useControlPanel(int id)
{
	int gate_id;

	if(m_control_panels[id]->activate(&gate_id))
	{
		if( m_control_panels[id]->is_intercom() )
			m_control_panels[id]->play_dialogue();
		else
			for( int i = 0; i < m_number_of_gates; i++ )
				if( m_blockers[i]->m_cp_id == gate_id )
					m_blockers[i]->activate();
	}	
}

void Level::obtainControlPanels(vector2 *position, vector2 *dimensions,int id)
{
	*position = m_control_panels[id]->get_pos();
	*dimensions = m_control_panels[id]->get_size();
}

void Level::notify_player_position (vector2 position)
{
	for(int i = 0; i < m_number_of_turrets; i++)
	{
		m_turrets[i]->notify_player_position(position);
	}

	for(int i = 0; i < m_number_of_traps; i++)
	{
		m_traps[i]->notify_player_position(position);
	}

	for(int i = 0; i < MAX_PROJECTILES; i++)
	{
		if(m_projectile[i]->active())
		{
			m_projectile[i]->notify_player_position(position);
		}
	}
}

int Level::collectableCollision(vector2 min_extent, vector2 max_extent)
{
	bool collect = false;

	for(int i = 0; i < m_number_of_collectables; i++)
	{
		if(m_collectables[i]->active())
		{
			vector2 pos = m_collectables[i]->get_pos();
			vector2 size = m_collectables[i]->get_size();

			//top left
			if(pos.x > min_extent.x && pos.x < max_extent.x 
				&& pos.y > min_extent.y && pos.y < max_extent.y)
			{
				m_collectables[i]->collect();
				collect = true;
			}

			//top right
			if(pos.x + size.x > min_extent.x && pos.x + size.x < max_extent.x 
				&& pos.y > min_extent.y && pos.y < max_extent.y)
			{
				m_collectables[i]->collect();
				collect = true;
			}

			//bottom right
			if(pos.x + size.x > min_extent.x && pos.x + size.x < max_extent.x 
				&& pos.y + size.y > min_extent.y && pos.y + size.y < max_extent.y)
			{
				m_collectables[i]->collect();
				collect = true;
			}

			//bottom left
			if(pos.x > min_extent.x && pos.x < max_extent.x 
				&& pos.y + size.y > min_extent.y && pos.y + size.y < max_extent.y)
			{
				m_collectables[i]->collect();
				collect = true;
			}

			if(collect)
			{
				g_sound_mgr_p->play(g_sound_id.collectable,-5);
				return m_collectables[i]->type();
				
			}
		}
	}

	return 0;

}

bool Level::projectileCollision(vector2 min_extent, vector2 max_extent)
{
	for(int i = 0; i < MAX_PROJECTILES; i++)
	{
		if(m_projectile[i]->active())
		{
			vector2 pos = m_projectile[i]->get_pos();

			int type = m_projectile[i]->get_type();

			if(type == 2)
			{
				vector2 size = m_projectile[i]->get_size();


				if(	   pos.x - size.x > min_extent.x && pos.x - size.x < max_extent.x
					|| pos.x + size.x > min_extent.x && pos.x + size.x < max_extent.x
					|| min_extent.x > pos.x - size.x && min_extent.x < pos.x + size.x
					|| max_extent.x > pos.x - size.x && max_extent.x < pos.x + size.x)
				{
				}
				else
				{
					return false;
				}

				if(	   pos.y - size.y > min_extent.y && pos.y - size.y < max_extent.y 
					|| pos.y + size.y > min_extent.y && pos.y + size.y < max_extent.y
					|| min_extent.y > pos.y - size.y && min_extent.y < pos.y + size.y
					|| max_extent.y > pos.y - size.y && max_extent.y < pos.y + size.y)
				{
					m_projectile[i]->kill();
					return true;
				}
				else
				{
					return false;
				}
			}
			else
			{
				if(pos.x > min_extent.x && pos.x < max_extent.x 
					&& pos.y > min_extent.y && pos.y < max_extent.y)
				{
					
					m_projectile[i]->kill();
					return true;
				}
			}
		}
	}

	return false;
}

short Level::get_tile(int index)
{ 
	if(index < 640)
	{
		return( m_tilemap_p[index] );
	}
	
	return 0;
}