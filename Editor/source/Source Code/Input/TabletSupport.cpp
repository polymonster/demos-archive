#include "TabletSupport.h"
#include "toolbars.h"

#ifdef _USE_TAB

PACKET localPacketBuf[NPACKETQSIZE];

HCTX NEAR TabletInit(HWND hWnd)
{
	LOGCONTEXT lcMine;
	HCTX hResult;

	/* get default system context. */
	WTInfo(WTI_DEFSYSCTX, 0, &lcMine);

	/* modify the digitizing context */
	wsprintf(lcMine.lcName, "SysPress Digitizing %x", g_hInstance);

	/* same define constants from top of file used in context definition. */
	lcMine.lcPktData = PACKETDATA;
	lcMine.lcPktMode = PACKETMODE;
	lcMine.lcMoveMask = PACKETDATA;

	/* inherit default button down mask. */
	/* allows tablet control panel to reserve some buttons for special */
	/* functions. */
	/* make sure we get button up AND down reports for all buttons we watch. */
	lcMine.lcBtnUpMask = lcMine.lcBtnDnMask;

	/* x & y match mouse points. */
	lcMine.lcOutOrgX = 0;
	lcMine.lcOutExtX = GetSystemMetrics(SM_CXSCREEN);
	lcMine.lcOutOrgY = 0;
	/* the negative sign here reverses the sense of the Y axis. */
	/* WinTab uses a lower-left origin; MM_TEXT uses upper left. */
	lcMine.lcOutExtY = -GetSystemMetrics(SM_CYSCREEN);

	/* open the context */
	hResult = WTOpen(hWnd, &lcMine, TRUE);

	/* Q size set needs error-checking, but skipped here for */
	/* simplicity's sake. */
	WTQueueSizeSet(hResult, NPACKETQSIZE);

	return hResult;
}
/*------------------------------------------------------------------------------
The functions PrsInit and PrsAdjust make sure that our pressure out can always
reach the full 0-255 range we desire, regardless of the button pressed or the
"pressure button marks" settings.
------------------------------------------------------------------------------*/
/* pressure adjuster local state. */
/* need wOldCsr = -1, so PrsAdjust will call PrsInit first time */
static UINT wActiveCsr = 0,  wOldCsr = (UINT)-1;
static BYTE wPrsBtn;
static UINT prsYesBtnOrg, prsYesBtnExt, prsNoBtnOrg, prsNoBtnExt;
/* -------------------------------------------------------------------------- */
void PrsInit(void)
{
	/* browse WinTab's many info items to discover pressure handling. */
	AXIS np;
	LOGCONTEXT lc;
	BYTE logBtns[32];
	UINT btnMarks[2];
	UINT size;

	/* discover the LOGICAL button generated by the pressure channel. */
	/* get the PHYSICAL button from the cursor category and run it */
	/* through that cursor's button map (usually the identity map). */
	wPrsBtn = (BYTE)-1;
	WTInfo(WTI_CURSORS + wActiveCsr, CSR_NPBUTTON, &wPrsBtn);
	size = WTInfo(WTI_CURSORS + wActiveCsr, CSR_BUTTONMAP, &logBtns);
	if ((UINT)wPrsBtn < size)
		wPrsBtn = logBtns[wPrsBtn];

	/* get the current context for its device variable. */
	WTGet(hTab, &lc);

	/* get the size of the pressure axis. */
	WTInfo(WTI_DEVICES + lc.lcDevice, DVC_NPRESSURE, &np);
	prsNoBtnOrg = (UINT)np.axMin;
	prsNoBtnExt = (UINT)np.axMax - (UINT)np.axMin;

	/* get the button marks (up & down generation thresholds) */
	/* and calculate what pressure range we get when pressure-button is down. */
	btnMarks[1] = 0; /* default if info item not present. */
	WTInfo(WTI_CURSORS + wActiveCsr, CSR_NPBTNMARKS, btnMarks);
	prsYesBtnOrg = btnMarks[1];
	prsYesBtnExt = (UINT)np.axMax - btnMarks[1];
}
/* -------------------------------------------------------------------------- */
UINT PrsAdjust(PACKET p)
{
	UINT wResult;

	wActiveCsr = p.pkCursor;
	if (wActiveCsr != wOldCsr) {

		/* re-init on cursor change. */
		PrsInit();
		wOldCsr = wActiveCsr;
	}

	/* scaling output range is 0-255 */

	if (p.pkButtons & (1 << wPrsBtn)) {
		/* if pressure-activated button is down, */
		/* scale pressure output to compensate btn marks */
		wResult = p.pkNormalPressure - prsYesBtnOrg;
		wResult = MulDiv(wResult, 255, prsYesBtnExt);
	}
	else {
		/* if pressure-activated button is not down, */
		/* scale pressure output directly */
		wResult = p.pkNormalPressure - prsNoBtnOrg;
		wResult = MulDiv(wResult, 255, prsNoBtnExt);
	}

	return wResult;
}

#endif